<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libinput: Initialization and manipulation of libinput contexts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libinput
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">A wrapper library for input devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Initialization and manipulation of libinput contexts</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga973479431a48cc5c4a292f98869c4831"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga973479431a48cc5c4a292f98869c4831">libinput_log_handler</a> )(enum <a class="el" href="libinput_8h.html#aa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> priority, void *user_data, const char *format, va_list args)</td></tr>
<tr class="memdesc:ga973479431a48cc5c4a292f98869c4831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log handler type for custom logging.  <a href="#ga973479431a48cc5c4a292f98869c4831">More...</a><br/></td></tr>
<tr class="separator:ga973479431a48cc5c4a292f98869c4831"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac30276a06e8b1434b959f2c8dde74f7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a> { <br/>
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7cabccc2f8bdff4e6ff42d3e1318864af67">LIBINPUT_EVENT_NONE</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca4da18343b29cc16ae2df09b9a3bff33b">LIBINPUT_EVENT_DEVICE_ADDED</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09">LIBINPUT_EVENT_DEVICE_REMOVED</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca477833897722f621bd10bbf3771302d3">LIBINPUT_EVENT_KEYBOARD_KEY</a>, 
<br/>
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca1812725b7fac7f096cb5d667a6bf89e9">LIBINPUT_EVENT_POINTER_MOTION</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca5e277107f22df970e882ef76dd6cc315">LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca26d8ced7a6e63edefb7f72ddd4d1d689">LIBINPUT_EVENT_POINTER_BUTTON</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca507673764d93c8d46109b069a3ab9bde">LIBINPUT_EVENT_POINTER_AXIS</a>, 
<br/>
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7caa14993972db3e944b4e3f5e74dd99dcb">LIBINPUT_EVENT_TOUCH_DOWN</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca1b48aaefbee80a1cbbcb5986d650bc62">LIBINPUT_EVENT_TOUCH_UP</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7caa96855d3716c4dccd47a69753ed2d468">LIBINPUT_EVENT_TOUCH_MOTION</a>, 
<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7caaf4ed8adce078146aedac569e3178052">LIBINPUT_EVENT_TOUCH_CANCEL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__base.html#ggac30276a06e8b1434b959f2c8dde74f7ca2b9b566a3bf1f460a144456697ee7387">LIBINPUT_EVENT_TOUCH_FRAME</a>
<br/>
 }</td></tr>
<tr class="memdesc:gac30276a06e8b1434b959f2c8dde74f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event type for events returned by <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a>.  <a href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">More...</a><br/></td></tr>
<tr class="separator:gac30276a06e8b1434b959f2c8dde74f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0301ab222fe4fe781563d00b7eeefdaf"><td class="memItemLeft" align="right" valign="top">struct libinput *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga0301ab222fe4fe781563d00b7eeefdaf">libinput_udev_create_for_seat</a> (const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *interface, void *user_data, struct udev *udev, const char *seat_id)</td></tr>
<tr class="memdesc:ga0301ab222fe4fe781563d00b7eeefdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new libinput context from udev, for input devices matching the given seat ID.  <a href="#ga0301ab222fe4fe781563d00b7eeefdaf">More...</a><br/></td></tr>
<tr class="separator:ga0301ab222fe4fe781563d00b7eeefdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363c6b6e47dcf410a3b3ebd5547c8b07"><td class="memItemLeft" align="right" valign="top">struct libinput *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07">libinput_path_create_context</a> (const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *interface, void *user_data)</td></tr>
<tr class="memdesc:ga363c6b6e47dcf410a3b3ebd5547c8b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new libinput context that requires the caller to manually add or remove devices with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a> and <a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121" title="Remove a device from a libinput context initialized with libinput_path_create_context() or added to s...">libinput_path_remove_device()</a>.  <a href="#ga363c6b6e47dcf410a3b3ebd5547c8b07">More...</a><br/></td></tr>
<tr class="separator:ga363c6b6e47dcf410a3b3ebd5547c8b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa797496f0150b482a4e01376bd33a47b"><td class="memItemLeft" align="right" valign="top">struct libinput_device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b">libinput_path_add_device</a> (struct libinput *libinput, const char *path)</td></tr>
<tr class="memdesc:gaa797496f0150b482a4e01376bd33a47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a device to a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a>.  <a href="#gaa797496f0150b482a4e01376bd33a47b">More...</a><br/></td></tr>
<tr class="separator:gaa797496f0150b482a4e01376bd33a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb53cdcce2c000001ac17706a612121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121">libinput_path_remove_device</a> (struct libinput_device *device)</td></tr>
<tr class="memdesc:ga9cb53cdcce2c000001ac17706a612121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device from a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a> or added to such a context with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a>.  <a href="#ga9cb53cdcce2c000001ac17706a612121">More...</a><br/></td></tr>
<tr class="separator:ga9cb53cdcce2c000001ac17706a612121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885a59371d4e8de0e18a2a2a66942e11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga885a59371d4e8de0e18a2a2a66942e11">libinput_get_fd</a> (struct libinput *libinput)</td></tr>
<tr class="memdesc:ga885a59371d4e8de0e18a2a2a66942e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">libinput keeps a single file descriptor for all events.  <a href="#ga885a59371d4e8de0e18a2a2a66942e11">More...</a><br/></td></tr>
<tr class="separator:ga885a59371d4e8de0e18a2a2a66942e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271f910ed17461830e48d4cd20483a00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00">libinput_dispatch</a> (struct libinput *libinput)</td></tr>
<tr class="memdesc:ga271f910ed17461830e48d4cd20483a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main event dispatchment function.  <a href="#ga271f910ed17461830e48d4cd20483a00">More...</a><br/></td></tr>
<tr class="separator:ga271f910ed17461830e48d4cd20483a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacead6670eaecf7c807659e2b6c725630"><td class="memItemLeft" align="right" valign="top">struct libinput_event *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630">libinput_get_event</a> (struct libinput *libinput)</td></tr>
<tr class="memdesc:gacead6670eaecf7c807659e2b6c725630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next event from libinput's internal event queue.  <a href="#gacead6670eaecf7c807659e2b6c725630">More...</a><br/></td></tr>
<tr class="separator:gacead6670eaecf7c807659e2b6c725630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86ad3c0c5bc27d8f630264f46cdf005"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#gac86ad3c0c5bc27d8f630264f46cdf005">libinput_next_event_type</a> (struct libinput *libinput)</td></tr>
<tr class="memdesc:gac86ad3c0c5bc27d8f630264f46cdf005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the next event in the internal queue.  <a href="#gac86ad3c0c5bc27d8f630264f46cdf005">More...</a><br/></td></tr>
<tr class="separator:gac86ad3c0c5bc27d8f630264f46cdf005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eab49413b8430c2eee987a39f4a410b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga3eab49413b8430c2eee987a39f4a410b">libinput_get_user_data</a> (struct libinput *libinput)</td></tr>
<tr class="separator:ga3eab49413b8430c2eee987a39f4a410b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1ee92fa05df27e3c0f37d524cc17a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6">libinput_resume</a> (struct libinput *libinput)</td></tr>
<tr class="memdesc:ga5a1ee92fa05df27e3c0f37d524cc17a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a suspended libinput context.  <a href="#ga5a1ee92fa05df27e3c0f37d524cc17a6">More...</a><br/></td></tr>
<tr class="separator:ga5a1ee92fa05df27e3c0f37d524cc17a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60662dc666f6188dc207467c9d8e99ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga60662dc666f6188dc207467c9d8e99ab">libinput_suspend</a> (struct libinput *libinput)</td></tr>
<tr class="memdesc:ga60662dc666f6188dc207467c9d8e99ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend monitoring for new devices and close existing devices.  <a href="#ga60662dc666f6188dc207467c9d8e99ab">More...</a><br/></td></tr>
<tr class="separator:ga60662dc666f6188dc207467c9d8e99ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198be0deab08d6d35923b5495c799b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga198be0deab08d6d35923b5495c799b3b">libinput_destroy</a> (struct libinput *libinput)</td></tr>
<tr class="memdesc:ga198be0deab08d6d35923b5495c799b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the libinput context.  <a href="#ga198be0deab08d6d35923b5495c799b3b">More...</a><br/></td></tr>
<tr class="separator:ga198be0deab08d6d35923b5495c799b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c1a243a0854f623874bf3a295bbe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga9a7c1a243a0854f623874bf3a295bbe4">libinput_log_set_priority</a> (enum <a class="el" href="libinput_8h.html#aa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> priority)</td></tr>
<tr class="memdesc:ga9a7c1a243a0854f623874bf3a295bbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global log priority.  <a href="#ga9a7c1a243a0854f623874bf3a295bbe4">More...</a><br/></td></tr>
<tr class="separator:ga9a7c1a243a0854f623874bf3a295bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02cb0ff218299d1eb3b34580fa3e9f0a"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="libinput_8h.html#aa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga02cb0ff218299d1eb3b34580fa3e9f0a">libinput_log_get_priority</a> (void)</td></tr>
<tr class="memdesc:ga02cb0ff218299d1eb3b34580fa3e9f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global log priority.  <a href="#ga02cb0ff218299d1eb3b34580fa3e9f0a">More...</a><br/></td></tr>
<tr class="separator:ga02cb0ff218299d1eb3b34580fa3e9f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e0260b8cffcae7bec6ccadf3735af29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__base.html#ga4e0260b8cffcae7bec6ccadf3735af29">libinput_log_set_handler</a> (<a class="el" href="group__base.html#ga973479431a48cc5c4a292f98869c4831">libinput_log_handler</a> log_handler, void *user_data)</td></tr>
<tr class="memdesc:ga4e0260b8cffcae7bec6ccadf3735af29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global log handler.  <a href="#ga4e0260b8cffcae7bec6ccadf3735af29">More...</a><br/></td></tr>
<tr class="separator:ga4e0260b8cffcae7bec6ccadf3735af29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga973479431a48cc5c4a292f98869c4831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* libinput_log_handler)(enum <a class="el" href="libinput_8h.html#aa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> priority, void *user_data, const char *format, va_list args)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log handler type for custom logging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The priority of the current message </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data pointer as previously passed into <a class="el" href="group__base.html#ga4e0260b8cffcae7bec6ccadf3735af29" title="Set the global log handler. ">libinput_log_set_handler()</a> </td></tr>
    <tr><td class="paramname">format</td><td>Message format in printf-style </td></tr>
    <tr><td class="paramname">args</td><td>Message arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>libinput_set_log_priority </dd>
<dd>
<a class="el" href="group__base.html#ga4e0260b8cffcae7bec6ccadf3735af29" title="Set the global log handler. ">libinput_log_set_handler</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac30276a06e8b1434b959f2c8dde74f7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event type for events returned by <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7cabccc2f8bdff4e6ff42d3e1318864af67"></a>LIBINPUT_EVENT_NONE</em>&#160;</td><td class="fielddoc">
<p>This is not a real event type, and is only used to tell the user that no new event is available in the queue. </p>
<p>See <a class="el" href="group__base.html#gac86ad3c0c5bc27d8f630264f46cdf005" title="Return the type of the next event in the internal queue. ">libinput_next_event_type()</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca4da18343b29cc16ae2df09b9a3bff33b"></a>LIBINPUT_EVENT_DEVICE_ADDED</em>&#160;</td><td class="fielddoc">
<p>Signals that a device has been added to the context. </p>
<p>The device will not be read until the next time the user calls <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> and data is available.</p>
<p>This allows setting up initial device configuration before any events are created. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca971332bb0efebbfb240001466684dd09"></a>LIBINPUT_EVENT_DEVICE_REMOVED</em>&#160;</td><td class="fielddoc">
<p>Signals that a device has been removed. </p>
<p>No more events from the associated device will be in the queue or be queued after this event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca477833897722f621bd10bbf3771302d3"></a>LIBINPUT_EVENT_KEYBOARD_KEY</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca1812725b7fac7f096cb5d667a6bf89e9"></a>LIBINPUT_EVENT_POINTER_MOTION</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca5e277107f22df970e882ef76dd6cc315"></a>LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca26d8ced7a6e63edefb7f72ddd4d1d689"></a>LIBINPUT_EVENT_POINTER_BUTTON</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca507673764d93c8d46109b069a3ab9bde"></a>LIBINPUT_EVENT_POINTER_AXIS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7caa14993972db3e944b4e3f5e74dd99dcb"></a>LIBINPUT_EVENT_TOUCH_DOWN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca1b48aaefbee80a1cbbcb5986d650bc62"></a>LIBINPUT_EVENT_TOUCH_UP</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7caa96855d3716c4dccd47a69753ed2d468"></a>LIBINPUT_EVENT_TOUCH_MOTION</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7caaf4ed8adce078146aedac569e3178052"></a>LIBINPUT_EVENT_TOUCH_CANCEL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac30276a06e8b1434b959f2c8dde74f7ca2b9b566a3bf1f460a144456697ee7387"></a>LIBINPUT_EVENT_TOUCH_FRAME</em>&#160;</td><td class="fielddoc">
<p>Signals the end of a set of touchpoints at one device sample time. </p>
<p>This event has no coordinate information attached. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga198be0deab08d6d35923b5495c799b3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_destroy </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the libinput context. </p>
<p>After this, object references associated with the destroyed context are invalid and may not be interacted with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga271f910ed17461830e48d4cd20483a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main event dispatchment function. </p>
<p>Reads events of the file descriptors and processes them internally. Use <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a> to retrieve the events.</p>
<p>Dispatching does not necessarily queue libinput events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative errno on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gacead6670eaecf7c807659e2b6c725630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libinput_event* libinput_get_event </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the next event from libinput's internal event queue. </p>
<p>After handling the retrieved event, the caller must destroy it using <a class="el" href="group__event.html#ga1df956c16e26cbbd911e553ec081022a" title="Destroy the event. ">libinput_event_destroy()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next available event, or NULL if no event is available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga885a59371d4e8de0e18a2a2a66942e11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_get_fd </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>libinput keeps a single file descriptor for all events. </p>
<p>Call into <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a> if any events become available on this fd.</p>
<dl class="section return"><dt>Returns</dt><dd>the file descriptor used to notify of pending events. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3eab49413b8430c2eee987a39f4a410b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* libinput_get_user_data </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the caller-specific data previously assigned in libinput_create_udev(). </dd></dl>

</div>
</div>
<a class="anchor" id="ga02cb0ff218299d1eb3b34580fa3e9f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libinput_8h.html#aa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a> libinput_log_get_priority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global log priority. </p>
<p>Messages with priorities equal to or higher than the argument will be printed to the current log handler.</p>
<p>The default log priority is LIBINPUT_LOG_PRIORITY_ERROR.</p>
<dl class="section return"><dt>Returns</dt><dd>The minimum priority of log messages to print.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__base.html#ga4e0260b8cffcae7bec6ccadf3735af29" title="Set the global log handler. ">libinput_log_set_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e0260b8cffcae7bec6ccadf3735af29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_log_set_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__base.html#ga973479431a48cc5c4a292f98869c4831">libinput_log_handler</a>&#160;</td>
          <td class="paramname"><em>log_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global log handler. </p>
<p>Messages with priorities equal to or higher than the current log priority will be passed to the given log handler.</p>
<p>The default log handler prints to stderr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_handler</td><td>The log handler for library messages. </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data pointer, passed into the log handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__base.html#ga4e0260b8cffcae7bec6ccadf3735af29" title="Set the global log handler. ">libinput_log_set_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a7c1a243a0854f623874bf3a295bbe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_log_set_priority </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="libinput_8h.html#aa7e9ebbd1a13fe2ed6f44e69df3216e1">libinput_log_priority</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global log priority. </p>
<p>Messages with priorities equal to or higher than the argument will be printed to the current log handler.</p>
<p>The default log priority is LIBINPUT_LOG_PRIORITY_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The minimum priority of log messages to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__base.html#ga4e0260b8cffcae7bec6ccadf3735af29" title="Set the global log handler. ">libinput_log_set_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac86ad3c0c5bc27d8f630264f46cdf005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__base.html#gac30276a06e8b1434b959f2c8dde74f7c">libinput_event_type</a> libinput_next_event_type </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the next event in the internal queue. </p>
<p>This function does not pop the event off the queue and the next call to <a class="el" href="group__base.html#gacead6670eaecf7c807659e2b6c725630" title="Retrieve the next event from libinput&#39;s internal event queue. ">libinput_get_event()</a> returns that event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event type of the next available event or LIBINPUT_EVENT_NONE if no event is availble. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa797496f0150b482a4e01376bd33a47b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libinput_device* libinput_path_add_device </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a device to a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a>. </p>
<p>If successful, the device will be added to the internal list and re-opened on <a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6" title="Resume a suspended libinput context. ">libinput_resume()</a>. The device can be removed with <a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121" title="Remove a device from a libinput context initialized with libinput_path_create_context() or added to s...">libinput_path_remove_device()</a>.</p>
<p>If the device was successfully initialized, it is returned in the device argument. The lifetime of the returned device pointer is limited until the next <a class="el" href="group__base.html#ga271f910ed17461830e48d4cd20483a00" title="Main event dispatchment function. ">libinput_dispatch()</a>, use <a class="el" href="group__device.html#ga478f58d79c5c03fa2596157a70a2d649" title="Increase the refcount of the input device. ">libinput_device_ref()</a> to keep a permanent reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
    <tr><td class="paramname">path</td><td>Path to an input device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly initiated device on success, or NULL on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is an application bug to call this function on a libinput context initialized with <a class="el" href="group__base.html#ga0301ab222fe4fe781563d00b7eeefdaf" title="Create a new libinput context from udev, for input devices matching the given seat ID...">libinput_udev_create_for_seat()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga363c6b6e47dcf410a3b3ebd5547c8b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libinput* libinput_path_create_context </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new libinput context that requires the caller to manually add or remove devices with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a> and <a class="el" href="group__base.html#ga9cb53cdcce2c000001ac17706a612121" title="Remove a device from a libinput context initialized with libinput_path_create_context() or added to s...">libinput_path_remove_device()</a>. </p>
<p>The context is fully initialized but will not generate events until at least one device has been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The callback interface </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data passed to the various callback interfaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized, empty libinput context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9cb53cdcce2c000001ac17706a612121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_path_remove_device </td>
          <td>(</td>
          <td class="paramtype">struct libinput_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a device from a libinput context initialized with <a class="el" href="group__base.html#ga363c6b6e47dcf410a3b3ebd5547c8b07" title="Create a new libinput context that requires the caller to manually add or remove devices with libinpu...">libinput_path_create_context()</a> or added to such a context with <a class="el" href="group__base.html#gaa797496f0150b482a4e01376bd33a47b" title="Add a device to a libinput context initialized with libinput_path_create_context(). ">libinput_path_add_device()</a>. </p>
<p>Events already processed from this input device are kept in the queue, the LIBINPUT_EVENT_DEVICE_REMOVED event marks the end of events for this device.</p>
<p>If no matching device exists, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A libinput device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is an application bug to call this function on a libinput context initialized with <a class="el" href="group__base.html#ga0301ab222fe4fe781563d00b7eeefdaf" title="Create a new libinput context from udev, for input devices matching the given seat ID...">libinput_udev_create_for_seat()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a1ee92fa05df27e3c0f37d524cc17a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libinput_resume </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a suspended libinput context. </p>
<p>This re-enables device monitoring and adds existing devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__base.html#ga60662dc666f6188dc207467c9d8e99ab" title="Suspend monitoring for new devices and close existing devices. ">libinput_suspend</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga60662dc666f6188dc207467c9d8e99ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libinput_suspend </td>
          <td>(</td>
          <td class="paramtype">struct libinput *&#160;</td>
          <td class="paramname"><em>libinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend monitoring for new devices and close existing devices. </p>
<p>This all but terminates libinput but does keep the context valid to be resumed with <a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6" title="Resume a suspended libinput context. ">libinput_resume()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libinput</td><td>A previously initialized libinput context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0301ab222fe4fe781563d00b7eeefdaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libinput* libinput_udev_create_for_seat </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlibinput__interface.html">libinput_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct udev *&#160;</td>
          <td class="paramname"><em>udev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>seat_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new libinput context from udev, for input devices matching the given seat ID. </p>
<p>New devices or devices removed will appear as events during libinput_dispatch.</p>
<p><a class="el" href="group__base.html#ga0301ab222fe4fe781563d00b7eeefdaf" title="Create a new libinput context from udev, for input devices matching the given seat ID...">libinput_udev_create_for_seat()</a> succeeds even if no input device is available in this seat, or if devices are available but fail to open in <a class="el" href="structlibinput__interface.html#aaf06146a946c2b3b841a42b60257bad4">libinput_interface::open_restricted</a>. Devices that do not have the minimum capabilities to be recognized as pointer, keyboard or touch device are ignored. Such devices and those that failed to open ignored until the next call to <a class="el" href="group__base.html#ga5a1ee92fa05df27e3c0f37d524cc17a6" title="Resume a suspended libinput context. ">libinput_resume()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The callback interface </td></tr>
    <tr><td class="paramname">user_data</td><td>Caller-specific data passed to the various callback interfaces. </td></tr>
    <tr><td class="paramname">udev</td><td>An already initialized udev context </td></tr>
    <tr><td class="paramname">seat_id</td><td>A seat identifier. This string must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized libinput context, ready to handle events or NULL on error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 22 2014 08:13:47 for libinput by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
